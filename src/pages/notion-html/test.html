<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Indexing in PostgreSQL: A Deep Dive into Performance üöÄ</title><style>
    /* cspell:disable-file */
    /* webkit printing magic: print all background colors */
    html {
        -webkit-print-color-adjust: exact;
    }
    * {
        box-sizing: border-box;
        -webkit-print-color-adjust: exact;
    }
    
    html,
    body {
        margin: 0;
        padding: 0;
    }
    @media only screen {
        body {
            margin: 2em auto;
            max-width: 900px;
            color: rgb(55, 53, 47);
        }
    }
    
    body {
        line-height: 1.5;
        white-space: pre-wrap;
    }
    
    a,
    a.visited {
        color: inherit;
        text-decoration: underline;
    }
    
    .pdf-relative-link-path {
        font-size: 80%;
        color: #444;
    }
    
    h1,
    h2,
    h3 {
        letter-spacing: -0.01em;
        line-height: 1.2;
        font-weight: 600;
        margin-bottom: 0;
    }
    
    .page-title {
        font-size: 2.5rem;
        font-weight: 700;
        margin-top: 0;
        margin-bottom: 0.75em;
    }
    
    h1 {
        font-size: 1.875rem;
        margin-top: 1.875rem;
    }
    
    h2 {
        font-size: 1.5rem;
        margin-top: 1.5rem;
    }
    
    h3 {
        font-size: 1.25rem;
        margin-top: 1.25rem;
    }
    
    .source {
        border: 1px solid #ddd;
        border-radius: 3px;
        padding: 1.5em;
        word-break: break-all;
    }
    
    .callout {
        border-radius: 3px;
        padding: 1rem;
    }
    
    figure {
        margin: 1.25em 0;
        page-break-inside: avoid;
    }
    
    figcaption {
        opacity: 0.5;
        font-size: 85%;
        margin-top: 0.5em;
    }
    
    mark {
        background-color: transparent;
    }
    
    .indented {
        padding-left: 1.5em;
    }
    
    hr {
        background: transparent;
        display: block;
        width: 100%;
        height: 1px;
        visibility: visible;
        border: none;
        border-bottom: 1px solid rgba(55, 53, 47, 0.09);
    }
    
    img {
        max-width: 100%;
    }
    
    @media only print {
        img {
            max-height: 100vh;
            object-fit: contain;
        }
    }
    
    @page {
        margin: 1in;
    }
    
    .collection-content {
        font-size: 0.875rem;
    }
    
    .column-list {
        display: flex;
        justify-content: space-between;
    }
    
    .column {
        padding: 0 1em;
    }
    
    .column:first-child {
        padding-left: 0;
    }
    
    .column:last-child {
        padding-right: 0;
    }
    
    .table_of_contents-item {
        display: block;
        font-size: 0.875rem;
        line-height: 1.3;
        padding: 0.125rem;
    }
    
    .table_of_contents-indent-1 {
        margin-left: 1.5rem;
    }
    
    .table_of_contents-indent-2 {
        margin-left: 3rem;
    }
    
    .table_of_contents-indent-3 {
        margin-left: 4.5rem;
    }
    
    .table_of_contents-link {
        text-decoration: none;
        opacity: 0.7;
        border-bottom: 1px solid rgba(55, 53, 47, 0.18);
    }
    
    table,
    th,
    td {
        border: 1px solid rgba(55, 53, 47, 0.09);
        border-collapse: collapse;
    }
    
    table {
        border-left: none;
        border-right: none;
    }
    
    th,
    td {
        font-weight: normal;
        padding: 0.25em 0.5em;
        line-height: 1.5;
        min-height: 1.5em;
        text-align: left;
    }
    
    th {
        color: rgba(55, 53, 47, 0.6);
    }
    
    ol,
    ul {
        margin: 0;
        margin-block-start: 0.6em;
        margin-block-end: 0.6em;
    }
    
    li > ol:first-child,
    li > ul:first-child {
        margin-block-start: 0.6em;
    }
    
    ul > li {
        list-style: disc;
    }
    
    ul.to-do-list {
        padding-inline-start: 0;
    }
    
    ul.to-do-list > li {
        list-style: none;
    }
    
    .to-do-children-checked {
        text-decoration: line-through;
        opacity: 0.375;
    }
    
    ul.toggle > li {
        list-style: none;
    }
    
    ul {
        padding-inline-start: 1.7em;
    }
    
    ul > li {
        padding-left: 0.1em;
    }
    
    ol {
        padding-inline-start: 1.6em;
    }
    
    ol > li {
        padding-left: 0.2em;
    }
    
    .mono ol {
        padding-inline-start: 2em;
    }
    
    .mono ol > li {
        text-indent: -0.4em;
    }
    
    .toggle {
        padding-inline-start: 0em;
        list-style-type: none;
    }
    
    /* Indent toggle children */
    .toggle > li > details {
        padding-left: 1.7em;
    }
    
    .toggle > li > details > summary {
        margin-left: -1.1em;
    }
    
    .selected-value {
        display: inline-block;
        padding: 0 0.5em;
        background: rgba(206, 205, 202, 0.5);
        border-radius: 3px;
        margin-right: 0.5em;
        margin-top: 0.3em;
        margin-bottom: 0.3em;
        white-space: nowrap;
    }
    
    .collection-title {
        display: inline-block;
        margin-right: 1em;
    }
    
    .page-description {
        margin-bottom: 2em;
    }
    
    .simple-table {
        margin-top: 1em;
        font-size: 0.875rem;
        empty-cells: show;
    }
    .simple-table td {
        height: 29px;
        min-width: 120px;
    }
    
    .simple-table th {
        height: 29px;
        min-width: 120px;
    }
    
    .simple-table-header-color {
        background: rgb(247, 246, 243);
        color: black;
    }
    .simple-table-header {
        font-weight: 500;
    }
    
    time {
        opacity: 0.5;
    }
    
    .icon {
        display: inline-block;
        max-width: 1.2em;
        max-height: 1.2em;
        text-decoration: none;
        vertical-align: text-bottom;
        margin-right: 0.5em;
    }
    
    img.icon {
        border-radius: 3px;
    }
    
    .user-icon {
        width: 1.5em;
        height: 1.5em;
        border-radius: 100%;
        margin-right: 0.5rem;
    }
    
    .user-icon-inner {
        font-size: 0.8em;
    }
    
    .text-icon {
        border: 1px solid #000;
        text-align: center;
    }
    
    .page-cover-image {
        display: block;
        object-fit: cover;
        width: 100%;
        max-height: 30vh;
    }
    
    .page-header-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
    }
    
    .page-header-icon-with-cover {
        margin-top: -0.72em;
        margin-left: 0.07em;
    }
    
    .page-header-icon img {
        border-radius: 3px;
    }
    
    .link-to-page {
        margin: 1em 0;
        padding: 0;
        border: none;
        font-weight: 500;
    }
    
    p > .user {
        opacity: 0.5;
    }
    
    td > .user,
    td > time {
        white-space: nowrap;
    }
    
    input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 0.6em;
        vertical-align: middle;
    }
    
    p {
        margin-top: 0.5em;
        margin-bottom: 0.5em;
    }
    
    .image {
        border: none;
        margin: 1.5em 0;
        padding: 0;
        border-radius: 0;
        text-align: center;
    }
    
    .code,
    code {
        background: rgba(135, 131, 120, 0.15);
        border-radius: 3px;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-size: 85%;
        tab-size: 2;
    }
    
    code {
        color: #eb5757;
    }
    
    .code {
        padding: 1.5em 1em;
    }
    
    .code-wrap {
        white-space: pre-wrap;
        word-break: break-all;
    }
    
    .code > code {
        background: none;
        padding: 0;
        font-size: 100%;
        color: inherit;
    }
    
    blockquote {
        font-size: 1.25em;
        margin: 1em 0;
        padding-left: 1em;
        border-left: 3px solid rgb(55, 53, 47);
    }
    
    .bookmark {
        text-decoration: none;
        max-height: 8em;
        padding: 0;
        display: flex;
        width: 100%;
        align-items: stretch;
    }
    
    .bookmark-title {
        font-size: 0.85em;
        overflow: hidden;
        text-overflow: ellipsis;
        height: 1.75em;
        white-space: nowrap;
    }
    
    .bookmark-text {
        display: flex;
        flex-direction: column;
    }
    
    .bookmark-info {
        flex: 4 1 180px;
        padding: 12px 14px 14px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }
    
    .bookmark-image {
        width: 33%;
        flex: 1 1 180px;
        display: block;
        position: relative;
        object-fit: cover;
        border-radius: 1px;
    }
    
    .bookmark-description {
        color: rgba(55, 53, 47, 0.6);
        font-size: 0.75em;
        overflow: hidden;
        max-height: 4.5em;
        word-break: break-word;
    }
    
    .bookmark-href {
        font-size: 0.75em;
        margin-top: 0.25em;
    }
    
    .sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
    .code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
    .serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
    .mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
    .pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
    .pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
    .pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
    .pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
    .pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
    .pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
    .pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
    .pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
    .pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
    .pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
    .pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
    .pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
    .pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
    .pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
    .pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
    .pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
    .highlight-default {
        color: rgba(50, 48, 44, 1);
    }
    .highlight-gray {
        color: rgba(115, 114, 110, 1);
        fill: rgba(115, 114, 110, 1);
    }
    .highlight-brown {
        color: rgba(159, 107, 83, 1);
        fill: rgba(159, 107, 83, 1);
    }
    .highlight-orange {
        color: rgba(217, 115, 13, 1);
        fill: rgba(217, 115, 13, 1);
    }
    .highlight-yellow {
        color: rgba(203, 145, 47, 1);
        fill: rgba(203, 145, 47, 1);
    }
    .highlight-teal {
        color: rgba(68, 131, 97, 1);
        fill: rgba(68, 131, 97, 1);
    }
    .highlight-blue {
        color: rgba(51, 126, 169, 1);
        fill: rgba(51, 126, 169, 1);
    }
    .highlight-purple {
        color: rgba(144, 101, 176, 1);
        fill: rgba(144, 101, 176, 1);
    }
    .highlight-pink {
        color: rgba(193, 76, 138, 1);
        fill: rgba(193, 76, 138, 1);
    }
    .highlight-red {
        color: rgba(205, 60, 58, 1);
        fill: rgba(205, 60, 58, 1);
    }
    .highlight-default_background {
        color: rgba(50, 48, 44, 1);
    }
    .highlight-gray_background {
        background: rgba(248, 248, 247, 1);
    }
    .highlight-brown_background {
        background: rgba(244, 238, 238, 1);
    }
    .highlight-orange_background {
        background: rgba(251, 236, 221, 1);
    }
    .highlight-yellow_background {
        background: rgba(251, 243, 219, 1);
    }
    .highlight-teal_background {
        background: rgba(237, 243, 236, 1);
    }
    .highlight-blue_background {
        background: rgba(231, 243, 248, 1);
    }
    .highlight-purple_background {
        background: rgba(248, 243, 252, 1);
    }
    .highlight-pink_background {
        background: rgba(252, 241, 246, 1);
    }
    .highlight-red_background {
        background: rgba(253, 235, 236, 1);
    }
    .block-color-default {
        color: inherit;
        fill: inherit;
    }
    .block-color-gray {
        color: rgba(115, 114, 110, 1);
        fill: rgba(115, 114, 110, 1);
    }
    .block-color-brown {
        color: rgba(159, 107, 83, 1);
        fill: rgba(159, 107, 83, 1);
    }
    .block-color-orange {
        color: rgba(217, 115, 13, 1);
        fill: rgba(217, 115, 13, 1);
    }
    .block-color-yellow {
        color: rgba(203, 145, 47, 1);
        fill: rgba(203, 145, 47, 1);
    }
    .block-color-teal {
        color: rgba(68, 131, 97, 1);
        fill: rgba(68, 131, 97, 1);
    }
    .block-color-blue {
        color: rgba(51, 126, 169, 1);
        fill: rgba(51, 126, 169, 1);
    }
    .block-color-purple {
        color: rgba(144, 101, 176, 1);
        fill: rgba(144, 101, 176, 1);
    }
    .block-color-pink {
        color: rgba(193, 76, 138, 1);
        fill: rgba(193, 76, 138, 1);
    }
    .block-color-red {
        color: rgba(205, 60, 58, 1);
        fill: rgba(205, 60, 58, 1);
    }
    .block-color-default_background {
        color: inherit;
        fill: inherit;
    }
    .block-color-gray_background {
        background: rgba(248, 248, 247, 1);
    }
    .block-color-brown_background {
        background: rgba(244, 238, 238, 1);
    }
    .block-color-orange_background {
        background: rgba(251, 236, 221, 1);
    }
    .block-color-yellow_background {
        background: rgba(251, 243, 219, 1);
    }
    .block-color-teal_background {
        background: rgba(237, 243, 236, 1);
    }
    .block-color-blue_background {
        background: rgba(231, 243, 248, 1);
    }
    .block-color-purple_background {
        background: rgba(248, 243, 252, 1);
    }
    .block-color-pink_background {
        background: rgba(252, 241, 246, 1);
    }
    .block-color-red_background {
        background: rgba(253, 235, 236, 1);
    }
    .select-value-color-default { background-color: rgba(84, 72, 49, 0.08); }
    .select-value-color-gray { background-color: rgba(84, 72, 49, 0.15); }
    .select-value-color-brown { background-color: rgba(210, 162, 141, 0.35); }
    .select-value-color-orange { background-color: rgba(224, 124, 57, 0.27); }
    .select-value-color-yellow { background-color: rgba(236, 191, 66, 0.39); }
    .select-value-color-green { background-color: rgba(123, 183, 129, 0.27); }
    .select-value-color-blue { background-color: rgba(93, 165, 206, 0.27); }
    .select-value-color-purple { background-color: rgba(168, 129, 197, 0.27); }
    .select-value-color-pink { background-color: rgba(225, 136, 179, 0.27); }
    .select-value-color-red { background-color: rgba(244, 171, 159, 0.4); }
    
    .checkbox {
        display: inline-flex;
        vertical-align: text-bottom;
        width: 16;
        height: 16;
        background-size: 16px;
        margin-left: 2px;
        margin-right: 5px;
    }
    
    .checkbox-on {
        background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
    }
    
    .checkbox-off {
        background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
    }
        
    </style></head><body><article id="2307958b-d6ff-8042-8105-d35f0539d23e" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">üï∞Ô∏è</span></div><h1 class="page-title">Indexing in PostgreSQL: A Deep Dive into Performance üöÄ</h1><p class="page-description"></p></header><div class="page-body"><p id="2307958b-d6ff-80ed-88e7-fa0279175a14" class="">At the heart of high-performance database operations lies the concept of indexing. In PostgreSQL, an index is a specialized data structure designed to dramatically speed up data retrieval operations on a table, akin to a book&#x27;s index guiding you directly to relevant information rather than forcing a full read. üìöüí®</p><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">The Trade-Offs of Indexing: Pros and Cons ‚öñÔ∏è</summary><div class="indented"><p id="2307958b-d6ff-802c-b002-eee74583bebd" class="">While indexes are indispensable for read performance, they come with trade-offs. Understanding these is key to judicious indexing.</p><p id="2307958b-d6ff-8008-bfb4-d53b1b8874b5" class=""><strong>Pros of Indexing üëç:</strong></p><ul id="2307958b-d6ff-80d8-8c8b-fdd04025bb03" class="bulleted-list"><li style="list-style-type:disc"><strong>Faster Data Retrieval:</strong> This is the primary benefit, as indexes allow PostgreSQL to quickly locate specific rows without scanning the entire table, drastically speeding up <code>SELECT</code> queries, especially with <code>WHERE</code>, <code>ORDER BY</code>, <code>GROUP BY</code>, and <code>JOIN</code> clauses. ‚ö°</li></ul><ul id="2307958b-d6ff-807f-8080-f3c894af99d4" class="bulleted-list"><li style="list-style-type:disc"><strong>Enforcing Uniqueness:</strong> Unique indexes prevent duplicate values in a column or set of columns, which is essential for data integrity (e.g., <code>PRIMARY KEY</code> and <code>UNIQUE</code> constraints implicitly create unique indexes). üîë</li></ul><ul id="2307958b-d6ff-80e7-876c-d3e0611dd0c3" class="bulleted-list"><li style="list-style-type:disc"><strong>Reduced Sorting Overhead:</strong> Indexes can store data in a pre-sorted order, allowing <code>ORDER BY</code> and <code>GROUP BY</code> operations to use the index directly instead of performing a costly in-memory or on-disk sort. ‚è±Ô∏è</li></ul><p id="2307958b-d6ff-800b-a366-f6e2ae38ebb1" class=""><strong>Cons of Indexing üëé:</strong></p><ul id="2307958b-d6ff-804e-b138-d7de5bc0e2a8" class="bulleted-list"><li style="list-style-type:disc"><strong>Increased Write Overhead:</strong> Every time data in an indexed column is <code>INSERTED</code>, <code>UPDATED</code>, or <code>DELETED</code>, the corresponding index must also be updated. This adds write overhead, slowing down DML operations. More indexes mean more updates. üêå</li></ul><ul id="2307958b-d6ff-80f6-8115-ebbf2d266cd9" class="bulleted-list"><li style="list-style-type:disc"><strong>Increased Disk Space:</strong> Indexes are separate data structures stored on disk, consuming additional storage space beyond the main table data. Larger indexes take more space. üíæ</li></ul><ul id="2307958b-d6ff-80fd-9d14-cb05934fb852" class="bulleted-list"><li style="list-style-type:disc"><strong>Maintenance Overhead:</strong> Indexes require maintenance (e.g., during <code>VACUUM</code> operations in PostgreSQL to reclaim space from dead tuples) and can become &quot;bloated&quot; over time, impacting performance if not managed. üßπ</li></ul><ul id="2307958b-d6ff-808b-8b8c-f9d7897b7f2b" class="bulleted-list"><li style="list-style-type:disc"><strong>Query Planner Complexity:</strong> Too many indexes, or poorly chosen indexes, can sometimes confuse the query planner, leading it to pick less optimal execution plans. ü§®</li></ul><p id="2307958b-d6ff-80ec-9977-d2d0bf87fc82" class=""><strong>Fighting the Cons: Mitigation Strategies üõ°Ô∏è:</strong></p><ul id="2307958b-d6ff-80d6-af91-f647f81c8763" class="bulleted-list"><li style="list-style-type:disc"><strong>Index Selectively:</strong> Only index columns frequently used in <code>WHERE</code> clauses, <code>JOIN</code> conditions, <code>ORDER BY</code>, or <code>GROUP BY</code>. Don&#x27;t index every column! üéØ</li></ul><ul id="2307958b-d6ff-80d7-ae3f-eab2dc067545" class="bulleted-list"><li style="list-style-type:disc"><strong>Choose Appropriate Types:</strong> Use the right index type for the job (e.g., B-Tree for general, GIN for JSONB/arrays). A well-suited index is more efficient. üí°</li></ul><ul id="2307958b-d6ff-80fa-9fbf-e649c12bf707" class="bulleted-list"><li style="list-style-type:disc"><strong>Monitor Performance:</strong> Regularly use <code>EXPLAIN ANALYZE</code> to see if your indexes are being used effectively and identify queries that might benefit from new or modified indexes. üìà</li></ul><ul id="2307958b-d6ff-80f4-8ed8-c43b49310091" class="bulleted-list"><li style="list-style-type:disc"><strong>Consider Partial Indexes:</strong> For columns where only a subset of rows is frequently queried (e.g., <code>WHERE status = &#x27;active&#x27;</code>), a partial index can be much smaller and faster to maintain. ü§è</li></ul><ul id="2307958b-d6ff-8091-976c-d7910cfd4ea4" class="bulleted-list"><li style="list-style-type:disc"><strong>Utilize Covering Indexes:</strong> For read-heavy workloads, create indexes that &quot;cover&quot; common queries (include all columns needed for <code>SELECT</code> and <code>WHERE</code> clauses) to enable <code>Index Only Scans</code>. This drastically reduces heap fetches. ‚ú®</li></ul><ul id="2307958b-d6ff-8072-b946-d518a59eaa69" class="bulleted-list"><li style="list-style-type:disc"><strong>Understand Your Workload:</strong> If your application is heavily write-dominated, fewer indexes might be better. If it&#x27;s read-dominated, more indexes (thoughtfully placed) are beneficial. üìä</li></ul></div></details><h3 id="2307958b-d6ff-807d-8e8b-e74dab55ff7c" class="">The Core Structure: Key-Value Pairs and TIDs üîë‚û°Ô∏èüìç</h3><p id="2307958b-d6ff-80f3-b850-caac30892807" class="">An index in PostgreSQL fundamentally operates as a highly optimized key-value store.</p><ul id="2307958b-d6ff-8003-b884-ff3b027206af" class="bulleted-list"><li style="list-style-type:disc"><strong>The Key:</strong> This represents the data from the column(s) on which the index is built (e.g., an <code>email</code> address üìß, an <code>order_id</code> üõçÔ∏è, or a combination of <code>last_name</code> and <code>first_name</code>).</li></ul><ul id="2307958b-d6ff-8060-ab0c-c4517a8dbf39" class="bulleted-list"><li style="list-style-type:disc"><strong>The Value:</strong> This is a pointer to the physical location of the corresponding row within the table&#x27;s main data file, known as the &quot;heap.&quot; This crucial pointer is called a <strong>TID</strong> (Tuple Identifier). A TID is a pair: <code>(block_number, item_offset)</code>.<ul id="2307958b-d6ff-8029-90a1-eac9294086ff" class="bulleted-list"><li style="list-style-type:circle"><code>block_number</code>: Specifies the 8KB page on disk where the tuple (row) resides. üíæ</li></ul><ul id="2307958b-d6ff-80f3-b941-e91ed31b4882" class="bulleted-list"><li style="list-style-type:circle"><code>item_offset</code>: Indicates the specific entry within that page&#x27;s array of <code>ItemIdData</code> (item pointers), which in turn points to the exact start of the tuple&#x27;s data. üéØ</li></ul></li></ul><p id="2307958b-d6ff-8077-8963-ca17cfbc6842" class="">When a query seeks a specific <code>email</code>, PostgreSQL can swiftly search the much smaller, highly organized index for the <code>email</code> (the key) to retrieve its TID (the value), allowing it to jump directly to the row&#x27;s physical location on disk, bypassing the need to scan the entire table. üèÉ‚Äç‚ôÇÔ∏èüí®</p><h3 id="2307958b-d6ff-807c-b478-e3bc3cf10e6f" class="">Pages: The Foundation of Storage üèóÔ∏èüìñ</h3><p id="2307958b-d6ff-804c-b684-dd4e2c73b32f" class="">To truly understand how indexes work, we must acknowledge the fundamental unit of storage: <strong>pages</strong>.</p><ul id="2307958b-d6ff-8026-b639-e7e9e0bb5142" class="bulleted-list"><li style="list-style-type:disc"><strong>Fixed Size:</strong> Both table data and index data are stored in 8KB pages (8192 bytes). PostgreSQL always reads or writes data in these 8KB chunks. üìè</li></ul><ul id="2307958b-d6ff-80a3-8eb5-f788a3d9d0ef" class="bulleted-list"><li style="list-style-type:disc"><strong>Internal Structure:</strong> Each page includes a header (containing metadata like checksums and free space offsets), an array of <code>ItemIdData</code> (pointers to tuples/items within the page), and the actual data (tuples for tables, key-TID pairs for indexes).</li></ul><ul id="2307958b-d6ff-806d-adc0-cb7075c33d45" class="bulleted-list"><li style="list-style-type:disc"><strong>Indexing Complement:</strong> The page number is an integral part of the TID. An index entry like <code>(&#x27;Smith&#x27;, (123, 5))</code> means &quot;the key &#x27;Smith&#x27; is found at page 123, at the location referenced by the 5th item pointer on that page.&quot; This page-centric design aligns perfectly with operating system and database buffer management optimizations for efficient disk I/O. ü§ù</li></ul><p id="2307958b-d6ff-800d-bcfd-d1fe8363efdf" class="">Let&#x27;s visualize how a simplified table page might look, and how TIDs play a role. Consider a <code>users</code> table: <code>(id INT, name TEXT, email TEXT)</code>.</p><p id="2307958b-d6ff-80aa-8a8c-cb0d789e0d0f" class=""><strong>Simplified Table Page (Page 123) üìä</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2307958b-d6ff-803e-a725-c2345ee5ead0" class="code"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">+-------------------------------------------------+
    |               PAGE HEADER (8 KB total)        |
    +-------------------------------------------------+
    |  pd_lsn (LSN of last change on this page)       |
    |  pd_checksum (Checksum for data integrity)      |
    |  pd_flags (Various flags for page status)       |
    |  pd_lower (Offset to start of free space)       |
    |  pd_upper (Offset to end of tuples)             |
    |  pd_special (Offset to start of special space)  |
    |  pd_pagesize_version (Page size &amp; version info) |
    |  pd_prune_xid (Transaction ID for pruning)      |
    +-------------------------------------------------+
    |             ITEM POINTERS (ItemIdData)          |
    +-------------------------------------------------+
    |  Offset to Tuple 1                              |  &lt;-- ItemIdData for Tuple 1 (TID: (123, 1))
    |  Offset to Tuple 2                              |  &lt;-- ItemIdData for Tuple 2 (TID: (123, 2))
    |  Offset to Tuple 3                              |  &lt;-- ItemIdData for Tuple 3 (TID: (123, 3))
    |  ...                                            |
    +-------------------------------------------------+
    |                 FREE SPACE                      |
    |                 (Grows downwards)               |
    +-------------------------------------------------+
    |                  TUPLES (Actual Row Data)       |
    |                  (Grows upwards)                |
    +-------------------------------------------------+
    |  Tuple 3: (id: 103, name: &#x27;Alice&#x27;, email: &#x27;a@e&#x27;)|  &lt;-- Physical Data for Tuple 3
    |  Tuple 2: (id: 102, name: &#x27;Bob&#x27;, email: &#x27;b@e&#x27;)  |  &lt;-- Physical Data for Tuple 2
    |  Tuple 1: (id: 101, name: &#x27;Charlie&#x27;, email: &#x27;c@e&#x27;)|&lt;-- Physical Data for Tuple 1
    +-------------------------------------------------+
    |                SPECIAL SPACE (e.g., for B-Trees) |
    +-------------------------------------------------+
    </code></pre><p id="2307958b-d6ff-8040-8f1f-f35677492d8d" class="">In this example, the <strong>TID</strong> for <code>Tuple 1</code> would be <code>(123, 1)</code>. <code>123</code> is the block (page) number, and <code>1</code> is the item pointer index <em>within</em> that page. So yes, the index value <em>does</em> refer to the page number as part of the TID! ‚úÖ</p><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">PostgreSQL Index Types üóÇÔ∏è‚ú®</summary><div class="indented"><p id="2307958b-d6ff-80e0-98e6-c983ac57150b" class="">PostgreSQL provides a variety of index types, each optimized for different data types and query patterns:</p><ol type="1" id="2307958b-d6ff-802d-81d0-f4c93ea914be" class="numbered-list" start="1"><li><strong>B-Tree:</strong> The default and most frequently used index type. It excels at equality (<code>=</code>), range (<code>&lt;</code>, <code>&gt;</code>, <code>BETWEEN</code>), and pattern matching (<code>LIKE &#x27;prefix%&#x27;</code>) queries on sortable data. It&#x27;s the go-to for most general-purpose indexing. üå≥</li></ol><ol type="1" id="2307958b-d6ff-8053-bd57-d26bc2cc4676" class="numbered-list" start="2"><li><strong>Hash:</strong> Optimized solely for equality comparisons (<code>=</code>). While potentially very fast for single-value lookups, they historically had limitations (e.g., not being crash-safe before PostgreSQL 10), making B-Tree a safer default. üé≤</li></ol><ol type="1" id="2307958b-d6ff-80cd-9167-dc172713795d" class="numbered-list" start="3"><li><strong>GIN (Generalized Inverted Index):</strong> Ideal for &quot;composite&quot; values or multi-value types. Common uses include indexing arrays (<code>text[]</code>), JSONB documents, and for full-text search. A GIN index efficiently answers questions like, &quot;Which documents contain <em>this specific word</em>?&quot; üìÑüîé</li></ol><ol type="1" id="2307958b-d6ff-8098-8c5e-d96c7b0e0872" class="numbered-list" start="4"><li><strong>GiST (Generalized Search Tree):</strong> A highly extensible, &quot;template&quot; index type for complex data structures and operations, particularly non-standard data types like geometric data (e.g., points, polygons, lines) or for full-text search where GiST&#x27;s unique capabilities (like k-nearest neighbor search) are valuable. üó∫Ô∏èüìê</li></ol><ol type="1" id="2307958b-d6ff-80d4-9b48-c25eec510d59" class="numbered-list" start="5"><li><strong>BRIN (Block Range Index):</strong> Designed for very large tables where data has a natural correlation with its physical storage order (e.g., a time-series table where new records are always appended with increasing timestamps). BRIN indexes are extremely small, storing only a summary (like min/max value) for large &quot;ranges&quot; of table blocks, making them highly efficient for queries targeting a specific time window in such ordered datasets. ‚è∞üß±</li></ol></div></details><h3 id="2307958b-d6ff-80d8-b5c0-c121b296b630" class="">Indexing Behavior in Real-World Scenarios üö¶üí°</h3><p id="2307958b-d6ff-8048-9a37-dc6958b454f1" class="">Understanding how PostgreSQL&#x27;s query planner leverages indexes under different conditions is critical for performance tuning.</p><ol type="1" id="2307958b-d6ff-8068-9708-cfe597c6be64" class="numbered-list" start="1"><li><strong>Multi-Column Indexes (</strong><code><strong>(col1, col2, col3)</strong></code><strong>):</strong> The order of columns matters extremely. An index on <code>(country, city, last_name)</code> is sorted first by <code>country</code>, then by <code>city</code> within each <code>country</code>, and finally by <code>last_name</code> within each <code>city</code>. üåçüë•<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2307958b-d6ff-8017-9dff-c6a609ac786e" class="code"><code class="language-SQL" style="white-space:pre-wrap;word-break:break-all">CREATE INDEX idx_customers_location_name ON customers (country, city, last_name);
    </code></pre><ul id="2307958b-d6ff-80ed-8317-ccad6e62d64d" class="bulleted-list"><li style="list-style-type:disc"><code>WHERE country = &#x27;USA&#x27;</code>: <strong>Uses the index.</strong> PostgreSQL can find all &#x27;USA&#x27; entries. The remaining part of the index (<code>city</code>, <code>last_name</code>) is still sorted, but it will read all &#x27;USA&#x27; entries. ‚úÖ</li></ul><ul id="2307958b-d6ff-808f-a9ac-d65ec5e52d27" class="bulleted-list"><li style="list-style-type:disc"><code>WHERE country = &#x27;USA&#x27; AND city = &#x27;New York&#x27;</code>: <strong>Uses the index optimally.</strong> It navigates directly to the &#x27;USA&#x27;, then &#x27;New York&#x27; section. üéØ</li></ul><ul id="2307958b-d6ff-80dc-b29e-fc38bdc94a78" class="bulleted-list"><li style="list-style-type:disc"><code>WHERE city = &#x27;London&#x27;</code>: <strong>Does NOT use the index.</strong> The leading column (<code>country</code>) is missing, preventing efficient index traversal. ‚ùå</li></ul><ul id="2307958b-d6ff-80d6-a351-e195b874cd46" class="bulleted-list"><li style="list-style-type:disc"><code>WHERE last_name = &#x27;Smith&#x27;</code>: <strong>Does NOT use the index.</strong> Same reason as above. ‚ùå</li></ul><ul id="2307958b-d6ff-80af-ac54-fe58d012abed" class="bulleted-list"><li style="list-style-type:disc"><code>WHERE country = &#x27;France&#x27; ORDER BY city</code>: <strong>Uses index</strong> and can provide the results pre-sorted, avoiding an expensive sort operation. üöÄ</li></ul><ul id="2307958b-d6ff-8097-84d9-eccb29671e2f" class="bulleted-list"><li style="list-style-type:disc"><code>WHERE country = &#x27;Germany&#x27; ORDER BY last_name</code>: <strong>Uses the index to filter by </strong><code><strong>country</strong></code>, but then it <strong>might need to sort</strong> the results by <code>last_name</code> <em>within</em> those German customers, as <code>last_name</code> is the third column and not directly ordered within the &#x27;Germany&#x27; part without considering <code>city</code>. The planner might still do an index scan for <code>country</code> and then a filesort, or it might decide to just do a sequential scan if the dataset is small enough after filtering by country. üßë‚Äçüíª</li></ul></li></ol><ol type="1" id="2307958b-d6ff-8075-85d5-d4cf2f50f36e" class="numbered-list" start="2"><li><strong>Filtering by Un-Indexed Columns (Post-Index Filtering):</strong><br/>Consider a query <br/><code>SELECT * FROM products WHERE category = &#x27;electronics&#x27; AND price &gt; 1000;</code> with an index only on <code>category</code>.<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2307958b-d6ff-8011-984b-feb83e7af7b5" class="code"><code class="language-SQL" style="white-space:pre-wrap;word-break:break-all">-- Index exists only on `category`
    CREATE INDEX idx_products_category ON products (category);
    </code></pre><ul id="2307958b-d6ff-8097-8d55-e46771415e7d" class="bulleted-list"><li style="list-style-type:disc"><strong>Execution Plan:</strong><ol type="1" id="2307958b-d6ff-80f2-a700-ca57e49800d3" class="numbered-list" start="1"><li><code>Index Scan using idx_products_category on products</code> (for <code>category = &#x27;electronics&#x27;</code>) ü§ñ</li></ol><ol type="1" id="2307958b-d6ff-8057-bd1b-d69ebcf9dd8b" class="numbered-list" start="2"><li><code>Recheck Condition: (price &gt; 1000)</code> (This happens on the rows fetched from the heap). ‚úÖ</li></ol></li></ul><p id="2307958b-d6ff-8067-8dcb-d1fe23bbd35d" class="">This is very common and effective. PostgreSQL quickly narrows down millions of products to, say, thousands of &#x27;electronics&#x27; products, then only reads those thousands of full rows from the heap to check the <code>price</code>. ‚ö°Ô∏è</p></li></ol><ol type="1" id="2307958b-d6ff-806b-9aa3-c70e1047dbc2" class="numbered-list" start="3"><li><strong>Using Functions/Expressions on Indexed Columns:</strong><br/>A query like <br/><code>SELECT * FROM users WHERE LOWER(email) = &#x27;john.doe@example.com&#x27;;</code> will typically <em>not</em> use a standard index on <code>email</code>. This is because the <code>LOWER()</code> function modifies the <code>email</code> value, preventing direct lookup in the pre-sorted index. üö´<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2307958b-d6ff-80c6-bb24-c582f24a002e" class="code"><code class="language-SQL" style="white-space:pre-wrap;word-break:break-all">-- Index on `email`
    CREATE INDEX idx_users_email ON users (email);
    </code></pre><ul id="2307958b-d6ff-8052-9323-d9c1c3cb25fc" class="bulleted-list"><li style="list-style-type:disc"><strong>Execution Plan:</strong> Likely a <code><strong>Seq Scan</strong></code>. üêå</li></ul><ul id="2307958b-d6ff-8029-9cab-e6cfb62573ab" class="bulleted-list"><li style="list-style-type:disc"><strong>Solution:</strong> Create an <strong>Expression Index (or Functional Index)</strong>:<br/>Now, the query can efficiently use this new index! üéâ<br/><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2307958b-d6ff-80e6-9409-fe15fc9d2064" class="code"><code class="language-SQL" style="white-space:pre-wrap;word-break:break-all">CREATE INDEX idx_users_email_lower ON users (LOWER(email));
    </code></pre></li></ul></li></ol><h3 id="2307958b-d6ff-807c-bc3b-fc1493697347" class="">Understanding Query Execution: Scan Types üìàüîç</h3><p id="2307958b-d6ff-802b-8f55-d8f1043300cf" class="">The PostgreSQL query planner selects the most efficient &quot;scan method&quot; to retrieve data. Observing these in <code>EXPLAIN ANALYZE</code> output is crucial for performance tuning. üïµÔ∏è‚Äç‚ôÄÔ∏è</p><ol type="1" id="2307958b-d6ff-800e-bfd9-fbf81450f9b6" class="numbered-list" start="1"><li><strong>Seq Scan (Sequential Scan):</strong><ul id="2307958b-d6ff-80ba-bb13-e0711d2a0032" class="bulleted-list"><li style="list-style-type:disc"><strong>Behavior:</strong> Reads every single data page of the entire table from start to finish, checking each row against the <code>WHERE</code> clause. üìñ</li></ul><ul id="2307958b-d6ff-80d9-8250-d38b403503d8" class="bulleted-list"><li style="list-style-type:disc"><strong>When Used:</strong> When no suitable index exists, the table is very small (index overhead isn&#x27;t justified), or a very large percentage of table rows (e.g., &gt;5-10%) are expected to be returned, making a full scan potentially faster than scattered index and heap lookups.</li></ul><ul id="2307958b-d6ff-80da-adfc-e75d86e87e7b" class="bulleted-list"><li style="list-style-type:disc"><strong>Performance:</strong> Generally slowest for selective queries on large tables. üê¢</li></ul></li></ol><ol type="1" id="2307958b-d6ff-8005-ae4b-d42bf55b42fa" class="numbered-list" start="2"><li><strong>Index Scan:</strong><ul id="2307958b-d6ff-80d2-88a9-c434c3acd5cb" class="bulleted-list"><li style="list-style-type:disc"><strong>Behavior:</strong> Uses an index to find the TIDs of matching rows, then fetches those specific rows (tuples) from their respective heap pages using the TIDs. ‚ö°Ô∏è</li></ul><ul id="2307958b-d6ff-80b3-bce3-d83d2f09aab8" class="bulleted-list"><li style="list-style-type:disc"><strong>When Used:</strong> When a selective <code>WHERE</code> clause can utilize an existing index.</li></ul><ul id="2307958b-d6ff-8029-8587-fda31583891a" class="bulleted-list"><li style="list-style-type:disc"><strong>Performance:</strong> Much faster than <code>Seq Scan</code> for selective queries by avoiding reading unnecessary data. üèéÔ∏è</li></ul></li></ol><ol type="1" id="2307958b-d6ff-8012-a295-dd97a106b2e2" class="numbered-list" start="3"><li><strong>Index Only Scan:</strong><ul id="2307958b-d6ff-8076-adaa-df2cb558c2bc" class="bulleted-list"><li style="list-style-type:disc"><strong>Behavior:</strong> The most optimized index scan. If <em>all</em> columns required by the <code>SELECT</code> list and <code>WHERE</code> clause are present within the index itself, PostgreSQL retrieves all necessary data directly from the index, entirely skipping the main table (heap) fetches. üåü</li></ul><ul id="2307958b-d6ff-8051-b43e-e0f5b81d4e8f" class="bulleted-list"><li style="list-style-type:disc"><strong>When Used:</strong> When a &quot;covering index&quot; (an index containing all necessary columns) exists and the data is &quot;visible&quot; (not recently modified by uncommitted transactions, which might require a heap check for visibility).</li></ul><ul id="2307958b-d6ff-80ec-b19f-f22e9a8fcb20" class="bulleted-list"><li style="list-style-type:disc"><strong>Performance:</strong> Extremely fast due to minimizing disk I/O to index pages only. üöÄüöÄüöÄ</li></ul></li></ol><ol type="1" id="2307958b-d6ff-8042-b4ad-c986b097efac" class="numbered-list" start="4"><li><strong>Bitmap Index Scan / Bitmap Heap Scan:</strong><ul id="2307958b-d6ff-808a-8483-f6afe0547b4a" class="bulleted-list"><li style="list-style-type:disc"><strong>Behavior:</strong> A two-step process often used for complex queries involving multiple indexes or less selective index conditions.<ol type="1" id="2307958b-d6ff-8010-82b4-fecfbe39f4cc" class="numbered-list" start="1"><li><strong>Bitmap Index Scan:</strong> One or more indexes are used to identify matching TIDs. Instead of fetching rows immediately, PostgreSQL builds a &quot;bitmap&quot; in memory, marking the heap blocks (or individual tuples) that contain qualifying rows. üó∫Ô∏è</li></ol><ol type="1" id="2307958b-d6ff-8027-8e2f-d53b3ba4daa0" class="numbered-list" start="2"><li><strong>Bitmap Heap Scan:</strong> PostgreSQL then accesses the actual heap pages based on this bitmap. It can read these pages in an optimized, often sequential, order to reduce random disk I/O, then filters the tuples within the retrieved pages. üß†</li></ol></li></ul><ul id="2307958b-d6ff-802c-bb0c-d4f79d493b43" class="bulleted-list"><li style="list-style-type:disc"><strong>When Used:</strong> Effectively combines selectivity from multiple indexes (e.g., <code>WHERE a = 1 OR b = 2</code>), or to optimize heap fetches for moderately selective index lookups by reducing random I/O.</li></ul><ul id="2307958b-d6ff-80ec-9cff-d2c647cab449" class="bulleted-list"><li style="list-style-type:disc"><strong>Performance:</strong> A good balance for complex queries, offering better performance than a <code>Seq Scan</code> while allowing for more flexible index usage than a strict <code>Index Scan</code>. ‚öñÔ∏è</li></ul></li></ol><p id="2307958b-d6ff-8098-8ea6-d1890adbda2e" class="">
    </p><h3 id="2307958b-d6ff-8097-b806-dc0d89547669" class="">Understanding Data Storage: Heap vs. Index &amp; The Page Connection üß†üí°</h3><p id="2307958b-d6ff-80c1-92b1-d9b2a36a4163" class="">This section clarifies how PostgreSQL stores your data, contrasting the table&#x27;s &quot;heap&quot; with the index structure, and how pages are fundamental to both.</p><hr id="2307958b-d6ff-807a-acdf-cbcebb317191"/><p id="2307958b-d6ff-80d9-b994-c4339fef9467" class="">A crucial aspect of PostgreSQL&#x27;s architecture lies in the <strong>distinct yet complementary roles</strong> of the table&#x27;s data &quot;heap&quot; and the indexes.</p><ul id="2307958b-d6ff-8082-848f-d90c51f0a058" class="bulleted-list"><li style="list-style-type:disc">When a new row is <code>INSERTED</code> into a table, its data is placed into the main table data file (the &quot;heap&quot;) wherever the next available physical space is found.</li></ul><ul id="2307958b-d6ff-802f-9213-d2b6bbeebf42" class="bulleted-list"><li style="list-style-type:disc">This physical storage order of rows in the heap is essentially <strong>unordered</strong> from a column value perspective. ü§∑‚Äç‚ôÄÔ∏è</li></ul><ul id="2307958b-d6ff-803c-833c-d172581fe942" class="bulleted-list"><li style="list-style-type:disc">The <strong>TID</strong> (Tuple Identifier) <code>(block_number, item_offset)</code> assigned to this new row precisely reflects this physical location. üìç</li></ul><hr id="2307958b-d6ff-8007-846d-db662cbe8738"/><p id="2307958b-d6ff-800d-a890-e1140619e5ee" class="">Simultaneously, the <strong>index</strong>‚Äîwhich is a separate B-tree (specifically B+ tree) structure‚Äîreceives an entry for this new row.</p><ul id="2307958b-d6ff-8087-8f71-d608554efdd5" class="bulleted-list"><li style="list-style-type:disc">This entry comprises the <code>(indexed_column_value, new_row_TID)</code>.</li></ul><ul id="2307958b-d6ff-8026-802a-c6f466a4af90" class="bulleted-list"><li style="list-style-type:disc">The B-tree&#x27;s internal logic meticulously places this new entry into its proper sorted position within the index&#x27;s own structure.</li></ul><ul id="2307958b-d6ff-8006-9ad8-d62b2ce4db38" class="bulleted-list"><li style="list-style-type:disc">This ensures that the <strong>logical order of keys within the index is consistently maintained</strong>. üå≥üîÑ</li></ul><ul id="2307958b-d6ff-80a5-a63a-ed4af68b0cd8" class="bulleted-list"><li style="list-style-type:disc">This might involve internal node splits or reorganizations within the index&#x27;s own pages, but the overall sorted structure remains intact.</li></ul><hr id="2307958b-d6ff-80eb-97ce-ec2968983b06"/><p id="2307958b-d6ff-8011-ae4c-f350a41c57c4" class="">This brings us to a key point: <strong>indexes store only addresses (TIDs)</strong>, not full copies of row data.</p><ul id="2307958b-d6ff-8016-8930-de5cd0716758" class="bulleted-list"><li style="list-style-type:disc">This means that logically adjacent entries within the index can point to rows <strong>physically scattered across vastly different, non-contiguous pages</strong> in the main table&#x27;s heap.</li></ul><ul id="2307958b-d6ff-803c-b098-cd70bc23a17f" class="bulleted-list"><li style="list-style-type:disc"><strong>For example:</strong><ul id="2307958b-d6ff-8001-a0b7-e33788849ce2" class="bulleted-list"><li style="list-style-type:circle">Index entry <code>(&#x27;Alice&#x27;, TID_for_Alice)</code> where <code>TID_for_Alice</code> is <code>(Page 10, Offset 5)</code>.</li></ul><ul id="2307958b-d6ff-8033-a123-e9397335d362" class="bulleted-list"><li style="list-style-type:circle">Index entry <code>(&#x27;Bob&#x27;, TID_for_Bob)</code> where <code>TID_for_Bob</code> is <code>(Page 500, Offset 12)</code>.</li></ul><ul id="2307958b-d6ff-807f-8495-fd0baf8487f5" class="bulleted-list"><li style="list-style-type:circle">Index entry <code>(&#x27;Charlie&#x27;, TID_for_Charlie)</code> where <code>TID_for_Charlie</code> is <code>(Page 25, Offset 3)</code>.<br/>Even though &#x27;Alice&#x27;, &#x27;Bob&#x27;, and &#x27;Charlie&#x27; are adjacent alphabetically in the index, their full row data could be on wildly different pages on disk. üìö‚ÜîÔ∏èüíæ<br/></li></ul></li></ul><hr id="2307958b-d6ff-801c-8909-e0d1aef36202"/><p id="2307958b-d6ff-805b-a819-ce721dc0db9c" class="">This physical dispersion leads to <strong>random disk I/O</strong> during standard <code>Index Scans</code>, as PostgreSQL has to jump between many disparate heap pages to fetch full rows, which is significantly slower than sequential I/O. üêå</p><p id="2307958b-d6ff-8001-8b30-d36f39425618" class="">This highlights the immense power of an <code><strong>Index Only Scan</strong></code> ‚ú®, which:</p><ul id="2307958b-d6ff-80b1-95d8-df975ed1295f" class="bulleted-list"><li style="list-style-type:disc">Avoids heap fetches entirely if all necessary data is within the index itself.</li></ul><ul id="2307958b-d6ff-80d4-9801-cb3569785ab0" class="bulleted-list"><li style="list-style-type:disc">Leads to significantly faster, often sequential, reads directly from the index. üöÄ</li></ul><p id="2307958b-d6ff-804f-ad5a-d8361e7f4ba0" class=""><em>(It&#x27;s worth noting that some databases have a concept of &quot;clustered indexes&quot; where the physical order of table data is explicitly forced to match an index&#x27;s order. PostgreSQL doesn&#x27;t have true clustered indexes in the same way, though the </em><em><code>CLUSTER</code></em><em> command allows you to reorder a table once based on an index; this order isn&#x27;t automatically maintained on subsequent writes.)</em></p><hr id="2307958b-d6ff-8016-8708-dc71ea10d3d7"/><p id="2307958b-d6ff-80a0-9676-e777b4fb75b0" class="">Finally, it&#x27;s vital to understand that indexes are not just abstract structures. <strong>Indexes are B-tree (specifically B+ tree) structures that are themselves physically composed of 8KB PostgreSQL pages.</strong> üìÑüìö</p><ul id="2307958b-d6ff-802b-b770-ceb5d48045d4" class="bulleted-list"><li style="list-style-type:disc">Each node within the B-tree/B+ tree (root, internal, leaf) corresponds to one or more of these physical pages on disk. üíæ</li></ul><ul id="2307958b-d6ff-80cc-a69f-e236786602ce" class="bulleted-list"><li style="list-style-type:disc">When an index is built or updated, its B-tree nodes are populated with key-TID pairs or pointers to child nodes.</li></ul><ul id="2307958b-d6ff-8022-ad20-db57bed6e353" class="bulleted-list"><li style="list-style-type:disc">These nodes are then written to or split across their own dedicated 8KB pages.</li></ul><p id="2307958b-d6ff-80fe-954d-fa16870b1460" class="">This fuses the <strong>logical B-tree structure</strong> with the <strong>physical page-based storage model</strong>, illustrating why indexes are so potent for read performance while simultaneously introducing write overhead and storage considerations. ‚úÖ This sophisticated interplay underscores why indexes are so potent for read performance while simultaneously introducing write overhead and storage considerations. üí°</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>